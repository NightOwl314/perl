<HTML>
<HEAD>
<TITLE>perldebguts - Guts of Perl debugging</TITLE>
<LINK REL="stylesheet" HREF="../../Active.css" TYPE="text/css">
<LINK REV="made" HREF="mailto:">
</HEAD>

<BODY>
<TABLE BORDER=0 CELLPADDING=0 CELLSPACING=0 WIDTH=100%>
<TR><TD CLASS=block VALIGN=MIDDLE WIDTH=100% BGCOLOR="#cccccc">
<FONT SIZE=+1><STRONG><P CLASS=block>&nbsp;perldebguts - Guts of Perl debugging</P></STRONG></FONT>
</TD></TR>
</TABLE>

<A NAME="__index__"></A>
<!-- INDEX BEGIN -->

<UL>

	<LI><A HREF="#name">NAME</A></LI>
	<LI><A HREF="#description">DESCRIPTION</A></LI>
	<LI><A HREF="#debugger internals">Debugger Internals</A></LI>
	<UL>

		<LI><A HREF="#writing your own debugger">Writing Your Own Debugger</A></LI>
	</UL>

	<LI><A HREF="#frame listing output examples">Frame Listing Output Examples</A></LI>
	<LI><A HREF="#debugging regular expressions">Debugging regular expressions</A></LI>
	<UL>

		<LI><A HREF="#compiletime output">Compile-time output</A></LI>
		<LI><A HREF="#types of nodes">Types of nodes</A></LI>
		<LI><A HREF="#runtime output">Run-time output</A></LI>
	</UL>

	<LI><A HREF="#debugging perl memory usage">Debugging Perl memory usage</A></LI>
	<UL>

		<LI><A HREF="#using $env{perl_debug_mstats}">Using <CODE>$ENV{PERL_DEBUG_MSTATS}</CODE></A></LI>
		<LI><A HREF="#example of using dl switch">Example of using <STRONG>-DL</STRONG> switch</A></LI>
		<LI><A HREF="#dl details"><STRONG>-DL</STRONG> details</A></LI>
		<LI><A HREF="#limitations of dl statistics">Limitations of <STRONG>-DL</STRONG> statistics</A></LI>
	</UL>

	<LI><A HREF="#see also">SEE ALSO</A></LI>
</UL>
<!-- INDEX END -->

<HR>
<P>
<H1><A NAME="name">NAME</A></H1>
<P>perldebguts - Guts of Perl debugging</P>
<P>
<HR>
<H1><A NAME="description">DESCRIPTION</A></H1>
<P>This is not the <CODE>perldebug(1)</CODE> manpage, which tells you how to use
the debugger.  This manpage describes low-level details ranging
between difficult and impossible for anyone who isn't incredibly
intimate with Perl's guts to understand.  Caveat lector.</P>
<P>
<HR>
<H1><A NAME="debugger internals">Debugger Internals</A></H1>
<P>Perl has special debugging hooks at compile-time and run-time used
to create debugging environments.  These hooks are not to be confused
with the <EM>perl -Dxxx</EM> command described in <A HREF="../../lib/Pod/perlrun.html">the perlrun manpage</A>, which is
usable only if a special Perl is built per the instructions in the
<EM>INSTALL</EM> podpage in the Perl source tree.</P>
<P>For example, whenever you call Perl's built-in <A HREF="../../lib/Pod/perlfunc.html#item_caller"><CODE>caller</CODE></A> function
from the package DB, the arguments that the corresponding stack
frame was called with are copied to the @DB::args array.  The
general mechanisms is enabled by calling Perl with the <STRONG>-d</STRONG> switch, the
following additional features are enabled (cf. <A HREF="../../lib/Pod/perlvar.html#$^p">$^P in the perlvar manpage</A>):</P>
<UL>
<LI>
Perl inserts the contents of <CODE>$ENV{PERL5DB}</CODE> (or <CODE>BEGIN {require
'perl5db.pl'}</CODE> if not present) before the first line of your program.
<P></P>
<LI>
Each array <CODE>@{&quot;_&lt;$filename&quot;}</CODE> holds the lines of $filename for a
file compiled by Perl.  The same for <A HREF="../../lib/Pod/perlfunc.html#item_eval"><CODE>eval</CODE></A>ed strings that contain
subroutines, or which are currently being executed.  The $filename
for <A HREF="../../lib/Pod/perlfunc.html#item_eval"><CODE>eval</CODE></A>ed strings looks like <CODE>(eval 34)</CODE>.   Code assertions
in regexes look like <CODE>(re_eval 19)</CODE>.
<P>Values in this array are magical in numeric context: they compare
equal to zero only if the line is not breakable.</P>
<P></P>
<LI>
Each hash <CODE>%{&quot;_&lt;$filename&quot;}</CODE> contains breakpoints and actions keyed
by line number.  Individual entries (as opposed to the whole hash)
are settable.  Perl only cares about Boolean true here, although
the values used by <EM>perl5db.pl</EM> have the form
<CODE>&quot;$break_condition\0$action&quot;</CODE>.
<P>The same holds for evaluated strings that contain subroutines, or
which are currently being executed.  The $filename for <A HREF="../../lib/Pod/perlfunc.html#item_eval"><CODE>eval</CODE></A>ed strings
looks like <CODE>(eval 34)</CODE> or  <CODE>(re_eval 19)</CODE>.</P>
<P></P>
<LI>
Each scalar <CODE>${&quot;_&lt;$filename&quot;}</CODE> contains <CODE>&quot;_&lt;$filename&quot;</CODE>.  This is
also the case for evaluated strings that contain subroutines, or
which are currently being executed.  The $filename for <A HREF="../../lib/Pod/perlfunc.html#item_eval"><CODE>eval</CODE></A>ed
strings looks like <CODE>(eval 34)</CODE> or <CODE>(re_eval 19)</CODE>.
<P></P>
<LI>
After each <A HREF="../../lib/Pod/perlfunc.html#item_require"><CODE>require</CODE></A>d file is compiled, but before it is executed,
<CODE>DB::postponed(*{&quot;_&lt;$filename&quot;})</CODE> is called if the subroutine
<CODE>DB::postponed</CODE> exists.  Here, the $filename is the expanded name of
the <A HREF="../../lib/Pod/perlfunc.html#item_require"><CODE>require</CODE></A>d file, as found in the values of %INC.
<P></P>
<LI>
After each subroutine <CODE>subname</CODE> is compiled, the existence of
<CODE>$DB::postponed{subname}</CODE> is checked.  If this key exists,
<CODE>DB::postponed(subname)</CODE> is called if the <CODE>DB::postponed</CODE> subroutine
also exists.
<P></P>
<LI>
A hash <CODE>%DB::sub</CODE> is maintained, whose keys are subroutine names
and whose values have the form <CODE>filename:startline-endline</CODE>.
<CODE>filename</CODE> has the form <CODE>(eval 34)</CODE> for subroutines defined inside
<A HREF="../../lib/Pod/perlfunc.html#item_eval"><CODE>eval</CODE></A>s, or <CODE>(re_eval 19)</CODE> for those within regex code assertions.
<P></P>
<LI>
When the execution of your program reaches a point that can hold a
breakpoint, the <CODE>DB::DB()</CODE> subroutine is called any of the variables
$DB::trace, $DB::single, or $DB::signal is true.  These variables
are not <A HREF="../../lib/Pod/perlfunc.html#item_local"><CODE>local</CODE></A>izable.  This feature is disabled when executing
inside <CODE>DB::DB()</CODE>, including functions called from it 
unless <CODE>$^D &amp; (1&lt;&lt;30)</CODE> is true.
<P></P>
<LI>
When execution of the program reaches a subroutine call, a call to
<CODE>&amp;DB::sub</CODE>(<EM>args</EM>) is made instead, with <CODE>$DB::sub</CODE> holding the
name of the called subroutine.  This doesn't happen if the subroutine
was compiled in the <CODE>DB</CODE> package.)
<P></P></UL>
<P>Note that if <CODE>&amp;DB::sub</CODE> needs external data for it to work, no
subroutine call is possible until this is done.  For the standard
debugger, the  <CODE>$DB::deep</CODE> variable (how many levels of recursion
deep into the debugger you can go before a mandatory break) gives
an example of such a dependency.</P>
<P>
<H2><A NAME="writing your own debugger">Writing Your Own Debugger</A></H2>
<P>The minimal working debugger consists of one line</P>
<PRE>
  sub DB::DB {}</PRE>
<P>which is quite handy as contents of <A HREF="../../lib/Pod/perlrun.html#item_PERL5DB"><CODE>PERL5DB</CODE></A> environment
variable:</P>
<PRE>
  $ PERL5DB=&quot;sub DB::DB {}&quot; perl -d your-script</PRE>
<P>Another brief debugger, slightly more useful, could be created
with only the line:</P>
<PRE>
  sub DB::DB {print ++$i; scalar &lt;STDIN&gt;}</PRE>
<P>This debugger would print the sequential number of encountered
statement, and would wait for you to hit a newline before continuing.</P>
<P>The following debugger is quite functional:</P>
<PRE>
  {
    package DB;
    sub DB  {}
    sub sub {print ++$i, &quot; $sub\n&quot;; &amp;$sub}
  }</PRE>
<P>It prints the sequential number of subroutine call and the name of the
called subroutine.  Note that <CODE>&amp;DB::sub</CODE> should be compiled into the
package <CODE>DB</CODE>.</P>
<P>At the start, the debugger reads your rc file (<EM>./.perldb</EM> or
<EM>~/.perldb</EM> under Unix), which can set important options.  This file may
define a subroutine <CODE>&amp;afterinit</CODE> to be executed after the debugger is
initialized.</P>
<P>After the rc file is read, the debugger reads the PERLDB_OPTS
environment variable and parses this as the remainder of a <CODE>O ...</CODE>
line as one might enter at the debugger prompt.</P>
<P>The debugger also maintains magical internal variables, such as
<CODE>@DB::dbline</CODE>, <CODE>%DB::dbline</CODE>, which are aliases for
<CODE>@{&quot;::_&lt;current_file&quot;}</CODE> <CODE>%{&quot;::_&lt;current_file&quot;}</CODE>.  Here <CODE>current_file</CODE>
is the currently selected file, either explicitly chosen with the
debugger's <A HREF="../../lib/Pod/perlguts.html#item_f"><CODE>f</CODE></A> command, or implicitly by flow of execution.</P>
<P>Some functions are provided to simplify customization.  See
<A HREF="../../lib/Pod/perldebug.html#options">Options in the perldebug manpage</A> for description of options parsed by
<CODE>DB::parse_options(string)</CODE>.  The function <CODE>DB::dump_trace(skip[,
count])</CODE> skips the specified number of frames and returns a list
containing information about the calling frames (all of them, if
<CODE>count</CODE> is missing).  Each entry is reference to a hash with
keys <CODE>context</CODE> (either <CODE>.</CODE>, <CODE>$</CODE>, or <CODE>@</CODE>), <A HREF="../../lib/Pod/perlfunc.html#item_sub"><CODE>sub</CODE></A> (subroutine
name, or info about <A HREF="../../lib/Pod/perlfunc.html#item_eval"><CODE>eval</CODE></A>), <CODE>args</CODE> (<A HREF="../../lib/Pod/perlfunc.html#item_undef"><CODE>undef</CODE></A> or a reference to
an array), <CODE>file</CODE>, and <CODE>line</CODE>.</P>
<P>The function <CODE>DB::print_trace(FH, skip[, count[, short]])</CODE> prints
formatted info about caller frames.  The last two functions may be
convenient as arguments to <CODE>&lt;</CODE>, <CODE>&lt;&lt;</CODE> commands.</P>
<P>Note that any variables and functions that are not documented in
this manpages (or in <A HREF="../../lib/Pod/perldebug.html">the perldebug manpage</A>) are considered for internal   
use only, and as such are subject to change without notice.</P>
<P>
<HR>
<H1><A NAME="frame listing output examples">Frame Listing Output Examples</A></H1>
<P>The <CODE>frame</CODE> option can be used to control the output of frame 
information.  For example, contrast this expression trace:</P>
<PRE>
 $ perl -de 42
 Stack dump during die enabled outside of evals.</PRE>
<PRE>
 Loading DB routines from perl5db.pl patch level 0.94
 Emacs support available.</PRE>
<PRE>
 Enter h or `h h' for help.</PRE>
<PRE>
 main::(-e:1):   0
   DB&lt;1&gt; sub foo { 14 }</PRE>
<PRE>
   DB&lt;2&gt; sub bar { 3 }</PRE>
<PRE>
   DB&lt;3&gt; t print foo() * bar()
 main::((eval 172):3):   print foo() + bar();
 main::foo((eval 168):2):
 main::bar((eval 170):2):
 42</PRE>
<P>with this one, once the <CODE>O</CODE>ption <CODE>frame=2</CODE> has been set:</P>
<PRE>
   DB&lt;4&gt; O f=2
                frame = '2'
   DB&lt;5&gt; t print foo() * bar()
 3:      foo() * bar()
 entering main::foo
  2:     sub foo { 14 };
 exited main::foo
 entering main::bar
  2:     sub bar { 3 };
 exited main::bar
 42</PRE>
<P>By way of demonstration, we present below a laborious listing
resulting from setting your <CODE>PERLDB_OPTS</CODE> environment variable to
the value <CODE>f=n N</CODE>, and running <EM>perl -d -V</EM> from the command line.
Examples use various values of <A HREF="../../lib/Pod/perlguts.html#item_n"><CODE>n</CODE></A> are shown to give you a feel
for the difference between settings.  Long those it may be, this
is not a complete listing, but only excerpts.</P>
<OL>
<LI>
<PRE>
  entering main::BEGIN
   entering Config::BEGIN
    Package lib/Exporter.pm.
    Package lib/Carp.pm.
   Package lib/Config.pm.
   entering Config::TIEHASH
   entering Exporter::import
    entering Exporter::export
  entering Config::myconfig
   entering Config::FETCH
   entering Config::FETCH
   entering Config::FETCH
   entering Config::FETCH</PRE>
<LI>
<PRE>
  entering main::BEGIN
   entering Config::BEGIN
    Package lib/Exporter.pm.
    Package lib/Carp.pm.
   exited Config::BEGIN
   Package lib/Config.pm.
   entering Config::TIEHASH
   exited Config::TIEHASH
   entering Exporter::import
    entering Exporter::export
    exited Exporter::export
   exited Exporter::import
  exited main::BEGIN
  entering Config::myconfig
   entering Config::FETCH
   exited Config::FETCH
   entering Config::FETCH
   exited Config::FETCH
   entering Config::FETCH</PRE>
<LI>
<PRE>
  in  $=main::BEGIN() from /dev/null:0
   in  $=Config::BEGIN() from lib/Config.pm:2
    Package lib/Exporter.pm.
    Package lib/Carp.pm.
   Package lib/Config.pm.
   in  $=Config::TIEHASH('Config') from lib/Config.pm:644
   in  $=Exporter::import('Config', 'myconfig', 'config_vars') from /dev/null:0
    in  $=Exporter::export('Config', 'main', 'myconfig', 'config_vars') from li
  in  @=Config::myconfig() from /dev/null:0
   in  $=Config::FETCH(ref(Config), 'package') from lib/Config.pm:574
   in  $=Config::FETCH(ref(Config), 'baserev') from lib/Config.pm:574
   in  $=Config::FETCH(ref(Config), 'PERL_VERSION') from lib/Config.pm:574
   in  $=Config::FETCH(ref(Config), 'PERL_SUBVERSION') from lib/Config.pm:574
   in  $=Config::FETCH(ref(Config), 'osname') from lib/Config.pm:574
   in  $=Config::FETCH(ref(Config), 'osvers') from lib/Config.pm:574</PRE>
<LI>
<PRE>
  in  $=main::BEGIN() from /dev/null:0
   in  $=Config::BEGIN() from lib/Config.pm:2
    Package lib/Exporter.pm.
    Package lib/Carp.pm.
   out $=Config::BEGIN() from lib/Config.pm:0
   Package lib/Config.pm.
   in  $=Config::TIEHASH('Config') from lib/Config.pm:644
   out $=Config::TIEHASH('Config') from lib/Config.pm:644
   in  $=Exporter::import('Config', 'myconfig', 'config_vars') from /dev/null:0
    in  $=Exporter::export('Config', 'main', 'myconfig', 'config_vars') from lib/
    out $=Exporter::export('Config', 'main', 'myconfig', 'config_vars') from lib/
   out $=Exporter::import('Config', 'myconfig', 'config_vars') from /dev/null:0
  out $=main::BEGIN() from /dev/null:0
  in  @=Config::myconfig() from /dev/null:0
   in  $=Config::FETCH(ref(Config), 'package') from lib/Config.pm:574
   out $=Config::FETCH(ref(Config), 'package') from lib/Config.pm:574
   in  $=Config::FETCH(ref(Config), 'baserev') from lib/Config.pm:574
   out $=Config::FETCH(ref(Config), 'baserev') from lib/Config.pm:574
   in  $=Config::FETCH(ref(Config), 'PERL_VERSION') from lib/Config.pm:574
   out $=Config::FETCH(ref(Config), 'PERL_VERSION') from lib/Config.pm:574
   in  $=Config::FETCH(ref(Config), 'PERL_SUBVERSION') from lib/Config.pm:574</PRE>
<LI>
<PRE>
  in  $=main::BEGIN() from /dev/null:0
   in  $=Config::BEGIN() from lib/Config.pm:2
    Package lib/Exporter.pm.
    Package lib/Carp.pm.
   out $=Config::BEGIN() from lib/Config.pm:0
   Package lib/Config.pm.
   in  $=Config::TIEHASH('Config') from lib/Config.pm:644
   out $=Config::TIEHASH('Config') from lib/Config.pm:644
   in  $=Exporter::import('Config', 'myconfig', 'config_vars') from /dev/null:0
    in  $=Exporter::export('Config', 'main', 'myconfig', 'config_vars') from lib/E
    out $=Exporter::export('Config', 'main', 'myconfig', 'config_vars') from lib/E
   out $=Exporter::import('Config', 'myconfig', 'config_vars') from /dev/null:0
  out $=main::BEGIN() from /dev/null:0
  in  @=Config::myconfig() from /dev/null:0
   in  $=Config::FETCH('Config=HASH(0x1aa444)', 'package') from lib/Config.pm:574
   out $=Config::FETCH('Config=HASH(0x1aa444)', 'package') from lib/Config.pm:574
   in  $=Config::FETCH('Config=HASH(0x1aa444)', 'baserev') from lib/Config.pm:574
   out $=Config::FETCH('Config=HASH(0x1aa444)', 'baserev') from lib/Config.pm:574</PRE>
<LI>
<PRE>
  in  $=CODE(0x15eca4)() from /dev/null:0
   in  $=CODE(0x182528)() from lib/Config.pm:2
    Package lib/Exporter.pm.
   out $=CODE(0x182528)() from lib/Config.pm:0
   scalar context return from CODE(0x182528): undef
   Package lib/Config.pm.
   in  $=Config::TIEHASH('Config') from lib/Config.pm:628
   out $=Config::TIEHASH('Config') from lib/Config.pm:628
   scalar context return from Config::TIEHASH:   empty hash
   in  $=Exporter::import('Config', 'myconfig', 'config_vars') from /dev/null:0
    in  $=Exporter::export('Config', 'main', 'myconfig', 'config_vars') from lib/Exporter.pm:171
    out $=Exporter::export('Config', 'main', 'myconfig', 'config_vars') from lib/Exporter.pm:171
    scalar context return from Exporter::export: ''
   out $=Exporter::import('Config', 'myconfig', 'config_vars') from /dev/null:0
   scalar context return from Exporter::import: ''</PRE>
</OL>
<P>In all cases shown above, the line indentation shows the call tree.
If bit 2 of <CODE>frame</CODE> is set, a line is printed on exit from a
subroutine as well.  If bit 4 is set, the arguments are printed
along with the caller info.  If bit 8 is set, the arguments are
printed even if they are tied or references.  If bit 16 is set, the
return value is printed, too.</P>
<P>When a package is compiled, a line like this</P>
<PRE>
    Package lib/Carp.pm.</PRE>
<P>is printed with proper indentation.</P>
<P>
<HR>
<H1><A NAME="debugging regular expressions">Debugging regular expressions</A></H1>
<P>There are two ways to enable debugging output for regular expressions.</P>
<P>If your perl is compiled with <CODE>-DDEBUGGING</CODE>, you may use the
<STRONG>-Dr</STRONG> flag on the command line.</P>
<P>Otherwise, one can <CODE>use re 'debug'</CODE>, which has effects at
compile time and run time.  It is not lexically scoped.</P>
<P>
<H2><A NAME="compiletime output">Compile-time output</A></H2>
<P>The debugging output at compile time looks like this:</P>
<PRE>
  compiling RE `[bc]d(ef*g)+h[ij]k$'
  size 43 first at 1
     1: ANYOF(11)
    11: EXACT &lt;d&gt;(13)
    13: CURLYX {1,32767}(27)
    15:   OPEN1(17)
    17:     EXACT &lt;e&gt;(19)
    19:     STAR(22)
    20:       EXACT &lt;f&gt;(0)
    22:     EXACT &lt;g&gt;(24)
    24:   CLOSE1(26)
    26:   WHILEM(0)
    27: NOTHING(28)
    28: EXACT &lt;h&gt;(30)
    30: ANYOF(40)
    40: EXACT &lt;k&gt;(42)
    42: EOL(43)
    43: END(0)
  anchored `de' at 1 floating `gh' at 3..2147483647 (checking floating)
                                    stclass `ANYOF' minlen 7</PRE>
<P>The first line shows the pre-compiled form of the regex.  The second
shows the size of the compiled form (in arbitrary units, usually
4-byte words) and the label <EM>id</EM> of the first node that does a
match.</P>
<P>The last line (split into two lines above) contains optimizer
information.  In the example shown, the optimizer found that the match 
should contain a substring <CODE>de</CODE> at offset 1, plus substring <CODE>gh</CODE>
at some offset between 3 and infinity.  Moreover, when checking for
these substrings (to abandon impossible matches quickly), Perl will check
for the substring <CODE>gh</CODE> before checking for the substring <CODE>de</CODE>.  The
optimizer may also use the knowledge that the match starts (at the
<CODE>first</CODE> <EM>id</EM>) with a character class, and the match cannot be
shorter than 7 chars.</P>
<P>The fields of interest which may appear in the last line are</P>
<DL>
<DT><STRONG><A NAME="item_anchored_STRING_at_POS"><A HREF="#item_anchored"><CODE>anchored</CODE></A> <EM>STRING</EM> <CODE>at</CODE> <EM>POS</EM></A></STRONG><BR>
<DD>
<DT><STRONG><A NAME="item_floating_STRING_at_POS1%2E%2EPOS2"><CODE>floating</CODE> <EM>STRING</EM> <CODE>at</CODE> <EM>POS1..POS2</EM></A></STRONG><BR>
<DD>
See above.
<P></P>
<DT><STRONG><A NAME="item_matching_floating%2Fanchored"><CODE>matching floating/anchored</CODE></A></STRONG><BR>
<DD>
Which substring to check first.
<P></P>
<DT><STRONG><A NAME="item_minlen"><CODE>minlen</CODE></A></STRONG><BR>
<DD>
The minimal length of the match.
<P></P>
<DT><STRONG><A NAME="item_stclass"><CODE>stclass</CODE> <EM>TYPE</EM></A></STRONG><BR>
<DD>
Type of first matching node.
<P></P>
<DT><STRONG><A NAME="item_noscan"><CODE>noscan</CODE></A></STRONG><BR>
<DD>
Don't scan for the found substrings.
<P></P>
<DT><STRONG><A NAME="item_isall"><CODE>isall</CODE></A></STRONG><BR>
<DD>
Means that the optimizer info is all that the regular
expression contains, and thus one does not need to enter the regex engine at
all.
<P></P>
<DT><STRONG><A NAME="item_GPOS"><CODE>GPOS</CODE></A></STRONG><BR>
<DD>
Set if the pattern contains <CODE>\G</CODE>.
<P></P>
<DT><STRONG><A NAME="item_plus"><CODE>plus</CODE></A></STRONG><BR>
<DD>
Set if the pattern starts with a repeated char (as in <CODE>x+y</CODE>).
<P></P>
<DT><STRONG><A NAME="item_implicit"><CODE>implicit</CODE></A></STRONG><BR>
<DD>
Set if the pattern starts with <CODE>.*</CODE>.
<P></P>
<DT><STRONG><A NAME="item_with_eval"><CODE>with eval</CODE></A></STRONG><BR>
<DD>
Set if the pattern contain eval-groups, such as <CODE>(?{ code })</CODE> and
<CODE>(??{ code })</CODE>.
<P></P>
<DT><STRONG><A NAME="item_anchored"><CODE>anchored(TYPE)</CODE></A></STRONG><BR>
<DD>
If the pattern may match only at a handful of places, (with <CODE>TYPE</CODE>
being <CODE>BOL</CODE>, <CODE>MBOL</CODE>, or <A HREF="#item_GPOS"><CODE>GPOS</CODE></A>.  See the table below.
<P></P></DL>
<P>If a substring is known to match at end-of-line only, it may be
followed by <CODE>$</CODE>, as in <CODE>floating `k'$</CODE>.</P>
<P>The optimizer-specific info is used to avoid entering (a slow) regex
engine on strings that will not definitely match.  If <A HREF="#item_isall"><CODE>isall</CODE></A> flag
is set, a call to the regex engine may be avoided even when the optimizer
found an appropriate place for the match.</P>
<P>The rest of the output contains the list of <EM>nodes</EM> of the compiled
form of the regex.  Each line has format</P>
<P><CODE>   </CODE><EM>id</EM>: <EM>TYPE</EM> <EM>OPTIONAL-INFO</EM> (<EM>next-id</EM>)</P>
<P>
<H2><A NAME="types of nodes">Types of nodes</A></H2>
<P>Here are the possible types, with short descriptions:</P>
<PRE>
    # TYPE arg-description [num-args] [longjump-len] DESCRIPTION</PRE>
<PRE>
    # Exit points
    END         no      End of program.
    SUCCEED     no      Return from a subroutine, basically.</PRE>
<PRE>
    # Anchors:
    BOL         no      Match &quot;&quot; at beginning of line.
    MBOL        no      Same, assuming multiline.
    SBOL        no      Same, assuming singleline.
    EOS         no      Match &quot;&quot; at end of string.
    EOL         no      Match &quot;&quot; at end of line.
    MEOL        no      Same, assuming multiline.
    SEOL        no      Same, assuming singleline.
    BOUND       no      Match &quot;&quot; at any word boundary
    BOUNDL      no      Match &quot;&quot; at any word boundary
    NBOUND      no      Match &quot;&quot; at any word non-boundary
    NBOUNDL     no      Match &quot;&quot; at any word non-boundary
    GPOS        no      Matches where last m//g left off.</PRE>
<PRE>
    # [Special] alternatives
    ANY         no      Match any one character (except newline).
    SANY        no      Match any one character.
    ANYOF       sv      Match character in (or not in) this class.
    ALNUM       no      Match any alphanumeric character
    ALNUML      no      Match any alphanumeric char in locale
    NALNUM      no      Match any non-alphanumeric character
    NALNUML     no      Match any non-alphanumeric char in locale
    SPACE       no      Match any whitespace character
    SPACEL      no      Match any whitespace char in locale
    NSPACE      no      Match any non-whitespace character
    NSPACEL     no      Match any non-whitespace char in locale
    DIGIT       no      Match any numeric character
    NDIGIT      no      Match any non-numeric character</PRE>
<PRE>
    # BRANCH    The set of branches constituting a single choice are hooked
    #           together with their &quot;next&quot; pointers, since precedence prevents
    #           anything being concatenated to any individual branch.  The
    #           &quot;next&quot; pointer of the last BRANCH in a choice points to the
    #           thing following the whole choice.  This is also where the
    #           final &quot;next&quot; pointer of each individual branch points; each
    #           branch starts with the operand node of a BRANCH node.
    #
    BRANCH      node    Match this alternative, or the next...</PRE>
<PRE>
    # BACK      Normal &quot;next&quot; pointers all implicitly point forward; BACK
    #           exists to make loop structures possible.
    # not used
    BACK        no      Match &quot;&quot;, &quot;next&quot; ptr points backward.</PRE>
<PRE>
    # Literals
    EXACT       sv      Match this string (preceded by length).
    EXACTF      sv      Match this string, folded (prec. by length).
    EXACTFL     sv      Match this string, folded in locale (w/len).</PRE>
<PRE>
    # Do nothing
    NOTHING     no      Match empty string.
    # A variant of above which delimits a group, thus stops optimizations
    TAIL        no      Match empty string. Can jump here from outside.</PRE>
<PRE>
    # STAR,PLUS '?', and complex '*' and '+', are implemented as circular
    #           BRANCH structures using BACK.  Simple cases (one character
    #           per match) are implemented with STAR and PLUS for speed
    #           and to minimize recursive plunges.
    #
    STAR        node    Match this (simple) thing 0 or more times.
    PLUS        node    Match this (simple) thing 1 or more times.</PRE>
<PRE>
    CURLY       sv 2    Match this simple thing {n,m} times.
    CURLYN      no 2    Match next-after-this simple thing 
    #                   {n,m} times, set parens.
    CURLYM      no 2    Match this medium-complex thing {n,m} times.
    CURLYX      sv 2    Match this complex thing {n,m} times.</PRE>
<PRE>
    # This terminator creates a loop structure for CURLYX
    WHILEM      no      Do curly processing and see if rest matches.</PRE>
<PRE>
    # OPEN,CLOSE,GROUPP ...are numbered at compile time.
    OPEN        num 1   Mark this point in input as start of #n.
    CLOSE       num 1   Analogous to OPEN.</PRE>
<PRE>
    REF         num 1   Match some already matched string
    REFF        num 1   Match already matched string, folded
    REFFL       num 1   Match already matched string, folded in loc.</PRE>
<PRE>
    # grouping assertions
    IFMATCH     off 1 2 Succeeds if the following matches.
    UNLESSM     off 1 2 Fails if the following matches.
    SUSPEND     off 1 1 &quot;Independent&quot; sub-regex.
    IFTHEN      off 1 1 Switch, should be preceded by switcher .
    GROUPP      num 1   Whether the group matched.</PRE>
<PRE>
    # Support for long regex
    LONGJMP     off 1 1 Jump far away.
    BRANCHJ     off 1 1 BRANCH with long offset.</PRE>
<PRE>
    # The heavy worker
    EVAL        evl 1   Execute some Perl code.</PRE>
<PRE>
    # Modifiers
    MINMOD      no      Next operator is not greedy.
    LOGICAL     no      Next opcode should set the flag only.</PRE>
<PRE>
    # This is not used yet
    RENUM       off 1 1 Group with independently numbered parens.</PRE>
<PRE>
    # This is not really a node, but an optimized away piece of a &quot;long&quot; node.
    # To simplify debugging output, we mark it as if it were a node
    OPTIMIZED   off     Placeholder for dump.</PRE>
<P>
<H2><A NAME="runtime output">Run-time output</A></H2>
<P>First of all, when doing a match, one may get no run-time output even
if debugging is enabled.  This means that the regex engine was never
entered and that all of the job was therefore done by the optimizer.</P>
<P>If the regex engine was entered, the output may look like this:</P>
<PRE>
  Matching `[bc]d(ef*g)+h[ij]k$' against `abcdefg__gh__'
    Setting an EVAL scope, savestack=3
     2 &lt;ab&gt; &lt;cdefg__gh_&gt;    |  1: ANYOF
     3 &lt;abc&gt; &lt;defg__gh_&gt;    | 11: EXACT &lt;d&gt;
     4 &lt;abcd&gt; &lt;efg__gh_&gt;    | 13: CURLYX {1,32767}
     4 &lt;abcd&gt; &lt;efg__gh_&gt;    | 26:   WHILEM
                                0 out of 1..32767  cc=effff31c
     4 &lt;abcd&gt; &lt;efg__gh_&gt;    | 15:     OPEN1
     4 &lt;abcd&gt; &lt;efg__gh_&gt;    | 17:     EXACT &lt;e&gt;
     5 &lt;abcde&gt; &lt;fg__gh_&gt;    | 19:     STAR
                             EXACT &lt;f&gt; can match 1 times out of 32767...
    Setting an EVAL scope, savestack=3
     6 &lt;bcdef&gt; &lt;g__gh__&gt;    | 22:       EXACT &lt;g&gt;
     7 &lt;bcdefg&gt; &lt;__gh__&gt;    | 24:       CLOSE1
     7 &lt;bcdefg&gt; &lt;__gh__&gt;    | 26:       WHILEM
                                    1 out of 1..32767  cc=effff31c
    Setting an EVAL scope, savestack=12
     7 &lt;bcdefg&gt; &lt;__gh__&gt;    | 15:         OPEN1
     7 &lt;bcdefg&gt; &lt;__gh__&gt;    | 17:         EXACT &lt;e&gt;
       restoring \1 to 4(4)..7
                                    failed, try continuation...
     7 &lt;bcdefg&gt; &lt;__gh__&gt;    | 27:         NOTHING
     7 &lt;bcdefg&gt; &lt;__gh__&gt;    | 28:         EXACT &lt;h&gt;
                                    failed...
                                failed...</PRE>
<P>The most significant information in the output is about the particular <EM>node</EM>
of the compiled regex that is currently being tested against the target string.
The format of these lines is</P>
<P><CODE>    </CODE><EM>STRING-OFFSET</EM> &lt;<EM>PRE-STRING</EM>&gt; &lt;<EM>POST-STRING</EM>&gt;   |<EM>ID</EM>:  <EM>TYPE</EM></P>
<P>The <EM>TYPE</EM> info is indented with respect to the backtracking level.
Other incidental information appears interspersed within.</P>
<P>
<HR>
<H1><A NAME="debugging perl memory usage">Debugging Perl memory usage</A></H1>
<P>Perl is a profligate wastrel when it comes to memory use.  There
is a saying that to estimate memory usage of Perl, assume a reasonable
algorithm for memory allocation, multiply that estimate by 10, and
while you still may miss the mark, at least you won't be quite so
astonished.  This is not absolutely true, but may provide a good
grasp of what happens.</P>
<P>Assume that an integer cannot take less than 20 bytes of memory, a
float cannot take less than 24 bytes, a string cannot take less
than 32 bytes (all these examples assume 32-bit architectures, the
result are quite a bit worse on 64-bit architectures).  If a variable
is accessed in two of three different ways (which require an integer,
a float, or a string), the memory footprint may increase yet another
20 bytes.  A sloppy <CODE>malloc(3)</CODE> implementation can inflate these
numbers dramatically.</P>
<P>On the opposite end of the scale, a declaration like</P>
<PRE>
  sub foo;</PRE>
<P>may take up to 500 bytes of memory, depending on which release of Perl
you're running.</P>
<P>Anecdotal estimates of source-to-compiled code bloat suggest an
eightfold increase.  This means that the compiled form of reasonable
(normally commented, properly indented etc.) code will take
about eight times more space in memory than the code took
on disk.</P>
<P>There are two Perl-specific ways to analyze memory usage:
$ENV{PERL_DEBUG_MSTATS} and <STRONG>-DL</STRONG> command-line switch.  The first
is available only if Perl is compiled with Perl's malloc(); the
second only if Perl was built with <CODE>-DDEBUGGING</CODE>.  See the
instructions for how to do this in the <EM>INSTALL</EM> podpage at 
the top level of the Perl source tree.</P>
<P>
<H2><A NAME="using $env{perl_debug_mstats}">Using <CODE>$ENV{PERL_DEBUG_MSTATS}</CODE></A></H2>
<P>If your perl is using Perl's <CODE>malloc()</CODE> and was compiled with the
necessary switches (this is the default), then it will print memory
usage statistics after compiling your code when <CODE>$ENV{PERL_DEBUG_MSTATS}
&gt; 1</CODE>, and before termination of the program when <CODE>&lt;
$ENV{PERL_DEBUG_MSTATS} </CODE>= 1 &gt;&gt;.  The report format is similar to
the following example:</P>
<PRE>
  $ PERL_DEBUG_MSTATS=2 perl -e &quot;require Carp&quot;
  Memory allocation statistics after compilation: (buckets 4(4)..8188(8192)
     14216 free:   130   117    28     7     9   0   2     2   1 0 0
                437    61    36     0     5
     60924 used:   125   137   161    55     7   8   6    16   2 0 1
                 74   109   304    84    20
  Total sbrk(): 77824/21:119. Odd ends: pad+heads+chain+tail: 0+636+0+2048.
  Memory allocation statistics after execution:   (buckets 4(4)..8188(8192)
     30888 free:   245    78    85    13     6   2   1     3   2 0 1
                315   162    39    42    11
    175816 used:   265   176  1112   111    26  22  11    27   2 1 1
                196   178  1066   798    39
  Total sbrk(): 215040/47:145. Odd ends: pad+heads+chain+tail: 0+2192+0+6144.</PRE>
<P>It is possible to ask for such a statistic at arbitrary points in
your execution using the <CODE>mstat()</CODE> function out of the standard
Devel::Peek module.</P>
<P>Here is some explanation of that format:</P>
<DL>
<DT><STRONG><A NAME="item_SMALLEST"><CODE>buckets SMALLEST(APPROX)..GREATEST(APPROX)</CODE></A></STRONG><BR>
<DD>
Perl's <CODE>malloc()</CODE> uses bucketed allocations.  Every request is rounded
up to the closest bucket size available, and a bucket is taken from
the pool of buckets of that size.
<P>The line above describes the limits of buckets currently in use.
Each bucket has two sizes: memory footprint and the maximal size
of user data that can fit into this bucket.  Suppose in the above
example that the smallest bucket were size 4.  The biggest bucket
would have usable size 8188, and the memory footprint would be 8192.</P>
<P>In a Perl built for debugging, some buckets may have negative usable
size.  This means that these buckets cannot (and will not) be used.
For larger buckets, the memory footprint may be one page greater
than a power of 2.  If so, case the corresponding power of two is
printed in the <CODE>APPROX</CODE> field above.</P>
<P></P>
<DT><STRONG><A NAME="item_Free%2FUsed">Free/Used</A></STRONG><BR>
<DD>
The 1 or 2 rows of numbers following that correspond to the number
of buckets of each size between <A HREF="#item_SMALLEST"><CODE>SMALLEST</CODE></A> and <CODE>GREATEST</CODE>.  In
the first row, the sizes (memory footprints) of buckets are powers
of two--or possibly one page greater.  In the second row, if present,
the memory footprints of the buckets are between the memory footprints
of two buckets ``above''.
<P>For example, suppose under the previous example, the memory footprints
were</P>
<PRE>
     free:    8     16    32    64    128  256 512 1024 2048 4096 8192
           4     12    24    48    80</PRE>
<P>With non-<CODE>DEBUGGING</CODE> perl, the buckets starting from <CODE>128</CODE> have
a 4-byte overhead, and thus a 8192-long bucket may take up to
8188-byte allocations.</P>
<P></P>
<DT><STRONG><A NAME="item_sbrk"><CODE>Total sbrk(): SBRKed/SBRKs:CONTINUOUS</CODE></A></STRONG><BR>
<DD>
The first two fields give the total amount of memory perl sbrk(2)ed
(ess-broken? :-) and number of sbrk(2)s used.  The third number is
what perl thinks about continuity of returned chunks.  So long as
this number is positive, <CODE>malloc()</CODE> will assume that it is probable
that <A HREF="#item_sbrk"><CODE>sbrk(2)</CODE></A> will provide continuous memory.
<P>Memory allocated by external libraries is not counted.</P>
<P></P>
<DT><STRONG><A NAME="item_pad%3A_0"><CODE>pad: 0</CODE></A></STRONG><BR>
<DD>
The amount of sbrk(2)ed memory needed to keep buckets aligned.
<P></P>
<DT><STRONG><A NAME="item_heads%3A_2192"><CODE>heads: 2192</CODE></A></STRONG><BR>
<DD>
Although memory overhead of bigger buckets is kept inside the bucket, for
smaller buckets, it is kept in separate areas.  This field gives the
total size of these areas.
<P></P>
<DT><STRONG><A NAME="item_chain%3A_0"><CODE>chain: 0</CODE></A></STRONG><BR>
<DD>
<CODE>malloc()</CODE> may want to subdivide a bigger bucket into smaller buckets.
If only a part of the deceased bucket is left unsubdivided, the rest
is kept as an element of a linked list.  This field gives the total
size of these chunks.
<P></P>
<DT><STRONG><A NAME="item_tail%3A_6144"><CODE>tail: 6144</CODE></A></STRONG><BR>
<DD>
To minimize the number of sbrk(2)s, <CODE>malloc()</CODE> asks for more memory.  This
field gives the size of the yet unused part, which is sbrk(2)ed, but
never touched.
<P></P></DL>
<P>
<H2><A NAME="example of using dl switch">Example of using <STRONG>-DL</STRONG> switch</A></H2>
<P>Below we show how to analyse memory usage by</P>
<PRE>
  do 'lib/auto/POSIX/autosplit.ix';</PRE>
<P>The file in question contains a header and 146 lines similar to</P>
<PRE>
  sub getcwd;</PRE>
<P><STRONG>WARNING</STRONG>: The discussion below supposes 32-bit architecture.  In 
newer releases of Perl, memory usage of the constructs discussed
here is greatly improved, but the story discussed below is a real-life
story.  This story is mercilessly terse, and assumes rather more than cursory
knowledge of Perl internals.  Type space to continue, `q' to quit. 
(Actually, you just want to skip to the next section.)</P>
<P>Here is the itemized list of Perl allocations performed during parsing
of this file:</P>
<PRE>
 !!! &quot;after&quot; at test.pl line 3.
    Id  subtot   4   8  12  16  20  24  28  32  36  40  48  56  64  72  80 80+
  0 02   13752   .   .   .   . 294   .   .   .   .   .   .   .   .   .   .   4
  0 54    5545   .   .   8 124  16   .   .   .   1   1   .   .   .   .   .   3
  5 05      32   .   .   .   .   .   .   .   1   .   .   .   .   .   .   .   .
  6 02    7152   .   .   .   .   .   .   .   .   .   . 149   .   .   .   .   .
  7 02    3600   .   .   .   .   . 150   .   .   .   .   .   .   .   .   .   .
  7 03      64   .  -1   .   1   .   .   2   .   .   .   .   .   .   .   .   .
  7 04    7056   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   7
  7 17   38404   .   .   .   .   .   .   .   1   .   . 442 149   .   . 147   .
  9 03    2078  17 249  32   .   .   .   .   2   .   .   .   .   .   .   .   .</PRE>
<P>To see this list, insert two <A HREF="../../lib/Pod/perlfunc.html#item_warn"><CODE>warn('!...')</CODE></A> statements around the call:</P>
<PRE>
  warn('!');
  do 'lib/auto/POSIX/autosplit.ix';
  warn('!!! &quot;after&quot;');</PRE>
<P>and run it with Perl's <STRONG>-DL</STRONG> option.  The first <A HREF="../../lib/Pod/perlfunc.html#item_warn"><CODE>warn()</CODE></A> will print
memory allocation info before parsing the file and will memorize
the statistics at this point (we ignore what it prints).  The second
<A HREF="../../lib/Pod/perlfunc.html#item_warn"><CODE>warn()</CODE></A> prints increments with respect to these memorized data.  This
is the printout shown above.</P>
<P>Different <EM>Id</EM>s on the left correspond to different subsystems of
the perl interpreter.  They are just the first argument given to
the perl memory allocation API named New().  To find what <CODE>9 03</CODE>
means, just <STRONG>grep</STRONG> the perl source for <CODE>903</CODE>.  You'll find it in
<EM>util.c</EM>, function savepvn().  (I know, you wonder why we told you
to <STRONG>grep</STRONG> and then gave away the answer.  That's because grepping
the source is good for the soul.)  This function is used to store
a copy of an existing chunk of memory.  Using a C debugger, one can
see that the function was called either directly from <CODE>gv_init()</CODE> or
via sv_magic(), and that <CODE>gv_init()</CODE> is called from gv_fetchpv()--which
was itself called from newSUB().  Please stop to catch your breath now.</P>
<P><STRONG>NOTE</STRONG>: To reach this point in the debugger and skip the calls to
<CODE>savepvn()</CODE> during the compilation of the main program, you should
set a C breakpoint
in Perl_warn(), continue until this point is reached, and <EM>then</EM> set
a C breakpoint in Perl_savepvn().  Note that you may need to skip a
handful of <CODE>Perl_savepvn()</CODE> calls that do not correspond to mass production
of CVs (there are more <CODE>903</CODE> allocations than 146 similar lines of
<EM>lib/auto/POSIX/autosplit.ix</EM>).  Note also that <CODE>Perl_</CODE> prefixes are
added by macroization code in perl header files to avoid conflicts
with external libraries.</P>
<P>Anyway, we see that <CODE>903</CODE> ids correspond to creation of globs, twice
per glob - for glob name, and glob stringification magic.</P>
<P>Here are explanations for other <EM>Id</EM>s above:</P>
<OL>
<LI>
Creates bigger <CODE>XPV*</CODE> structures.  In the case above, it
creates 3 <CODE>AV</CODE>s per subroutine, one for a list of lexical variable
names, one for a scratchpad (which contains lexical variables and
<CODE>targets</CODE>), and one for the array of scratchpads needed for
recursion.
<P>It also creates a <CODE>GV</CODE> and a <CODE>CV</CODE> per subroutine, all called from
start_subparse().</P>
<P></P>
<LI>
Creates a C array corresponding to the <CODE>AV</CODE> of scratchpads and the
scratchpad itself.  The first fake entry of this scratchpad is
created though the subroutine itself is not defined yet.
<P>It also creates C arrays to keep data for the stash.  This is one HV,
but it grows; thus, there are 4 big allocations: the big chunks are not
freed, but are kept as additional arenas for <CODE>SV</CODE> allocations.</P>
<P></P>
<LI>
Creates a <CODE>HEK</CODE> for the name of the glob for the subroutine.  This
name is a key in a <EM>stash</EM>.
<P>Big allocations with this <EM>Id</EM> correspond to allocations of new
arenas to keep <CODE>HE</CODE>.</P>
<P></P>
<LI>
Creates a <CODE>GP</CODE> for the glob for the subroutine.
<P></P>
<LI>
Creates the <CODE>MAGIC</CODE> for the glob for the subroutine.
<P></P>
<LI>
Creates <EM>arenas</EM> which keep SVs.
<P></P></OL>
<P>
<H2><A NAME="dl details"><STRONG>-DL</STRONG> details</A></H2>
<P>If Perl is run with <STRONG>-DL</STRONG> option, then warn()s that start with `!'
behave specially.  They print a list of <EM>categories</EM> of memory
allocations, and statistics of allocations of different sizes for
these categories.</P>
<P>If <A HREF="../../lib/Pod/perlfunc.html#item_warn"><CODE>warn()</CODE></A> string starts with</P>
<DL>
<DT><STRONG><A NAME="item_%21%21%21"><CODE>!!!</CODE></A></STRONG><BR>
<DD>
print changed categories only, print the differences in counts of allocations.
<P></P>
<DT><STRONG><A NAME="item_%21%21"><CODE>!!</CODE></A></STRONG><BR>
<DD>
print grown categories only; print the absolute values of counts, and totals.
<P></P>
<DT><STRONG><A NAME="item_%21"><CODE>!</CODE></A></STRONG><BR>
<DD>
print nonempty categories, print the absolute values of counts and totals.
<P></P></DL>
<P>
<H2><A NAME="limitations of dl statistics">Limitations of <STRONG>-DL</STRONG> statistics</A></H2>
<P>If an extension or external library does not use the Perl API to
allocate memory, such allocations are not counted.</P>
<P>
<HR>
<H1><A NAME="see also">SEE ALSO</A></H1>
<P><A HREF="../../lib/Pod/perldebug.html">the perldebug manpage</A>,
<A HREF="../../lib/Pod/perlguts.html">the perlguts manpage</A>,
<A HREF="../../lib/Pod/perlrun.html">the perlrun manpage</A>
<A HREF="../../lib/re.html">the re manpage</A>,
and
<A HREF="../../Devel/Dprof.html">the Devel::Dprof manpage</A>.</P>
<TABLE BORDER=0 CELLPADDING=0 CELLSPACING=0 WIDTH=100%>
<TR><TD CLASS=block VALIGN=MIDDLE WIDTH=100% BGCOLOR="#cccccc">
<FONT SIZE=+1><STRONG><P CLASS=block>&nbsp;perldebguts - Guts of Perl debugging</P></STRONG></FONT>
</TD></TR>
</TABLE>

</BODY>

</HTML>
